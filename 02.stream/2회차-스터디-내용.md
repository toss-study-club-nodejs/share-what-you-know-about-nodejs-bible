# 2회차 스터디 내용

## 대용량 파일 처리에 스트림을 적용했을때 성능 이점
- [실행_결과.md](%ED%95%9C%EC%98%88%EC%84%B1%2F%EC%8B%A4%ED%96%89_%EA%B2%B0%EA%B3%BC.md)
- 메모리 사용량 (200m 파일 기준)
  - **스트림 미사용**: 사용량이 선형적으로 증가하여 최대 800m에 근접한 메모리 사용량을 보였음
  - **스트림 사용**: 선형적인 증가 없이  20m 아래의 메모리 사용량을 유지함
- 이벤트 루프 (200m 파일 기준)
  - **스트림 미사용**: 파일을 읽기 시작하면서 부터 hang 이 걸리기 시작하였고 모든 작업이 끝났을때 까지 hang이 걸려있었음, ( 파일 처리가 진행되는 동안 다른 작업 모두 블락 상태 )
  - **스트림 사용**: 스트림을 생성하는 시점에 잠깐 튄 지점이 있지만 이 후 hang 없이 진행됨
- cpu 사용량
  - 스트림 사용 여부와 관계 없이 모두 동일한 사용량을 보였음
  - 이것은 csv 파일을 읽고 파싱하는 작업이 cpu 사용량에 영향을 주기 때문임. 
    테스트 코드에서는 csv 파일을 읽는데로 파싱작업이 들어가서 많은 텍스트를 동시에 파싱하기 때문에 cpu 사용량이 높게 나옴
  - 읽기 - [쓰로틀링] - 파싱 하는 중간 지점에 적절한 버퍼를 둬서 cpu 사용량을 줄일 수 있을 것으로 보임
- [테스트에 사용된 도구](https://clinicjs.org/)

## 스트림으로 변환하기 위한 코드 패턴
- 스트림을 사용하기 위해서는 readable 타입을 반환하거나, writeable 타입을 받아야함,

  하지만 대부분 작성하는 코드는 그렇지 못하여 스트림을 적용하기에 제한적임,

  그래서 작성된 코드를 readable, writeable 로 변환하는 작업을 해주면 스트림을 적용할 수 있음

  [readable 타입으로 변환하는 코드 패턴](%EB%B0%95%EC%A0%95%EC%9B%85%2F__test__%2Fsamples%2Ftransform-non-stream-code%2Fsample.ts)

## 파일처리 외 다른 부분에서 스트림을 적용 케이스
- 데이터 베이스에서 대량의 데이터를 가져와 후 처리하는 작업
- 데이터 베이스 조회 함수를 Generator 로 작성한다. [data-source.service.ts](%EB%B0%95%EC%A0%95%EC%9B%85%2F__test__%2Fsamples%2Fdb-to-http%2Fdata-source.service.ts)
- 이 후 Readable 스트림으로 변환후 write 스트림으로 파이프 시키면 됨 [sample.service.ts](%EB%B0%95%EC%A0%95%EC%9B%85%2F__test__%2Fsamples%2Fdb-to-http%2Fsample.service.ts)
- 이 케이스의 장점
  - 데이터를 가져오는 부분과 데이터를 처리하는 부분을 분리할 수 있음, 처리하는 부분의 로직이 추가되어도 getData 내부 함수의 변경이 필요없음
  - 청크 단위로 처리 되기 때문에 메모리 사용량을 일정량으로 유지됨
  - pipe 를 통해 여러 로직을 추가 결합하기 쉬운 구조임
- 이 케이스의 단점
  - 트렌젝션 처리가 필요하다면 로직이 복잡해짐, MSA 환경에서 적용되는 트랜젝션 전략을 사용하거나, 트랜젝션 처리를 위한 콜백 함수를 넘겨주는식의 전략이 필요함

## 스트림을 사용하면서 재시도나 예외 처리를 하는 방법
- RxJS 와 같은 라이브러리를 사용하면 쉽게 해결이 가능하다. e.g https://rxjs.dev/api/index/function/retry
- 예외 처리가 필요한 write, read stream 코드에 작성하거나 retry 기능을 프록시로 감싸서 pipe 한다.